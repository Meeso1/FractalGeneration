import numpy as np
from typing import Callable


def generate_dragon_sequence(iterations: int) -> str:
    """
    Generate the L-system string for a dragon curve.
    
    The dragon curve is generated by iteratively applying rules:
    - F -> F+G
    - G -> F-G
    
    Args:
        iterations: Number of iterations to apply the L-system rules
    
    Returns:
        The generated L-system string
    """
    sequence = "F"
    for _ in range(iterations):
        next_sequence = ""
        for char in sequence:
            if char == "F":
                next_sequence += "F+G"
            elif char == "G":
                next_sequence += "F-G"
            else:
                next_sequence += char
        sequence = next_sequence
    
    return sequence


def sequence_to_complex_points_with_angle_fn(sequence: str, angle_fn: Callable[[int], float]) -> np.ndarray:
    """
    Convert an L-system sequence to complex coordinate points using turtle graphics with dynamic angles.
    
    Interprets the string as turtle graphics commands:
    - F, G: move forward
    - +: turn left by angle determined by angle_fn
    - -: turn right by angle determined by angle_fn
    
    Args:
        sequence: The L-system string to interpret
        angle_fn: Function that takes iteration number and returns rotation angle in radians
    
    Returns:
        A 1D array of complex numbers representing points.
    """
    # Start at origin, facing right (direction = 1+0j)
    position = 0.0 + 0.0j
    direction = 1.0 + 0.0j
    
    # Store all points
    points = [position]
    
    # Track the iteration number
    iteration = 0
    
    angle = angle_fn(iteration)
    for char in sequence:
        if char == "F" or char == "G":
            # Move forward
            position = position + direction
            points.append(position)
            iteration += 1
        elif char == "+":
            # Turn left (counterclockwise)
            direction = direction * np.exp(1j * angle)
        elif char == "-":
            # Turn right (clockwise)
            direction = direction * np.exp(-1j * angle)
    
    return np.array(points)


def sequence_to_complex_points(sequence: str, angle: float = np.pi / 2) -> np.ndarray:
    """
    Convert an L-system sequence to complex coordinate points using turtle graphics.
    
    Interprets the string as turtle graphics commands:
    - F, G: move forward
    - +: turn left by angle
    - -: turn right by angle
    
    Args:
        sequence: The L-system string to interpret
        angle: The rotation angle in radians (default: π/2 for 90 degrees)
    
    Returns:
        A 1D array of complex numbers representing points.
    """
    return sequence_to_complex_points_with_angle_fn(sequence, lambda i: angle)


def complex_to_real_points(complex_points: np.ndarray) -> np.ndarray:
    """
    Convert complex points to real coordinate array.
    
    Args:
        complex_points: A 1D array of complex numbers
    
    Returns:
        A 2xn array defining points of the curve (x, y).
    """
    return np.array([complex_points.real, complex_points.imag])


def sequence_to_points_with_angle_fn(sequence: str, angle_fn: Callable[[int], float]) -> np.ndarray:
    """
    Convert an L-system sequence to coordinate points using turtle graphics with dynamic angles.
    
    Interprets the string as turtle graphics commands:
    - F, G: move forward
    - +: turn left by angle determined by angle_fn
    - -: turn right by angle determined by angle_fn
    
    Args:
        sequence: The L-system string to interpret
        angle_fn: Function that takes iteration number and returns rotation angle in radians
    
    Returns:
        A 2xn array defining points of the curve (x, y).
    """
    complex_points = sequence_to_complex_points_with_angle_fn(sequence, angle_fn)
    return complex_to_real_points(complex_points)


def sequence_to_points(sequence: str, angle: float = np.pi / 2) -> np.ndarray:
    """
    Convert an L-system sequence to coordinate points using turtle graphics.
    
    Interprets the string as turtle graphics commands:
    - F, G: move forward
    - +: turn left by angle
    - -: turn right by angle
    
    Args:
        sequence: The L-system string to interpret
        angle: The rotation angle in radians (default: π/2 for 90 degrees)
    
    Returns:
        A 2xn array defining points of the curve (x, y).
    """
    return sequence_to_points_with_angle_fn(sequence, lambda i: angle)


def dragon_curve_with_angle_fn(iterations: int, angle_fn: Callable[[int], float]) -> np.ndarray:
    """
    Generate a dragon curve fractal using L-system with dynamic angles.
    
    Args:
        iterations: Number of iterations to apply the L-system rules
        angle_fn: Function that takes iteration number and returns rotation angle in radians
    
    Returns:
        A 2xn array defining points of the curve (x, y).
    """
    sequence = generate_dragon_sequence(iterations)
    return sequence_to_points_with_angle_fn(sequence, angle_fn)


def dragon_curve(iterations: int, angle: float = np.pi / 2) -> np.ndarray:
    """
    Generate a dragon curve fractal using L-system.
    
    Args:
        iterations: Number of iterations to apply the L-system rules
        angle: The rotation angle in radians (default: π/2 for 90 degrees)
    
    Returns:
        A 2xn array defining points of the curve (x, y).
    """
    return dragon_curve_with_angle_fn(iterations, lambda i: angle)
