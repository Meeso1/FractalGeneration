import numpy as np
from typing import Callable


def generate_dragon_sequence(iterations: int) -> tuple[str, list[int]]:
    """
    Generate the L-system string for a dragon curve along with iteration metadata.
    
    The dragon curve is generated by iteratively applying rules:
    - F -> F+G
    - G -> F-G
    
    Args:
        iterations: Number of iterations to apply the L-system rules
    
    Returns:
        A tuple of (sequence, turn_iterations) where:
        - sequence: The generated L-system string
        - turn_iterations: A list of iteration numbers (0-indexed) for each turn (+/-)
    """
    sequence = "F"
    turn_iterations = []
    
    for iteration in range(iterations):
        next_sequence = ""
        next_iterations = []
        
        iter_index = 0  # Track position in the old turn_iterations list
        
        for char in sequence:
            if char == "F":
                next_sequence += "F+G"
                next_iterations.append(iteration)  # New turn added by F expansion
            elif char == "G":
                next_sequence += "F-G"
                next_iterations.append(iteration)  # New turn added by G expansion
            else:  # char is '+' or '-'
                next_sequence += char
                next_iterations.append(turn_iterations[iter_index])  # Copy existing turn
                iter_index += 1
        
        sequence = next_sequence
        turn_iterations = next_iterations
    
    return sequence, turn_iterations


def sequence_to_complex_points_with_angle_fn(sequence: str, angle_fn: Callable[[int], float], turn_iterations: list[int] | None = None) -> np.ndarray:
    """
    Convert an L-system sequence to complex coordinate points using turtle graphics with dynamic angles.
    
    Interprets the string as turtle graphics commands:
    - F, G: move forward
    - +: turn left by angle determined by angle_fn
    - -: turn right by angle determined by angle_fn
    
    Args:
        sequence: The L-system string to interpret
        angle_fn: Function that takes iteration number and returns rotation angle in radians
        turn_iterations: Optional list of iteration numbers for each turn in the sequence.
                        If provided, angles will be determined based on when each turn was introduced.
    
    Returns:
        A 1D array of complex numbers representing points.
    """
    # Start at origin, facing right (direction = 1+0j)
    position = 0.0 + 0.0j
    direction = 1.0 + 0.0j
    
    # Store all points
    points = [position]
    
    # Cache angles if turn_iterations is provided
    if turn_iterations is not None:
        unique_iterations = set(turn_iterations)
        angle_cache = {i: angle_fn(i) for i in unique_iterations}
        turn_index = 0
    else:
        # Fallback: use iteration 0 for all turns
        default_angle = angle_fn(0)
    
    for char in sequence:
        if char == "F" or char == "G":
            # Move forward
            position = position + direction
            points.append(position)
        elif char == "+":
            # Turn left (counterclockwise)
            if turn_iterations is not None:
                angle = angle_cache[turn_iterations[turn_index]]
                turn_index += 1
            else:
                angle = default_angle
            direction = direction * np.exp(1j * angle)
        elif char == "-":
            # Turn right (clockwise)
            if turn_iterations is not None:
                angle = angle_cache[turn_iterations[turn_index]]
                turn_index += 1
            else:
                angle = default_angle
            direction = direction * np.exp(-1j * angle)
    
    return np.array(points)


def sequence_to_complex_points(sequence: str, angle: float = np.pi / 2) -> np.ndarray:
    """
    Convert an L-system sequence to complex coordinate points using turtle graphics.
    
    Interprets the string as turtle graphics commands:
    - F, G: move forward
    - +: turn left by angle
    - -: turn right by angle
    
    Args:
        sequence: The L-system string to interpret
        angle: The rotation angle in radians (default: π/2 for 90 degrees)
    
    Returns:
        A 1D array of complex numbers representing points.
    """
    return sequence_to_complex_points_with_angle_fn(sequence, lambda i: angle)


def complex_to_real_points(complex_points: np.ndarray) -> np.ndarray:
    """
    Convert complex points to real coordinate array.
    
    Args:
        complex_points: A 1D array of complex numbers
    
    Returns:
        A 2xn array defining points of the curve (x, y).
    """
    return np.array([complex_points.real, complex_points.imag])


def sequence_to_points_with_angle_fn(sequence: str, angle_fn: Callable[[int], float], turn_iterations: list[int] | None = None) -> np.ndarray:
    """
    Convert an L-system sequence to coordinate points using turtle graphics with dynamic angles.
    
    Interprets the string as turtle graphics commands:
    - F, G: move forward
    - +: turn left by angle determined by angle_fn
    - -: turn right by angle determined by angle_fn
    
    Args:
        sequence: The L-system string to interpret
        angle_fn: Function that takes iteration number and returns rotation angle in radians
        turn_iterations: Optional list of iteration numbers for each turn in the sequence.
                        If provided, angles will be determined based on when each turn was introduced.
    
    Returns:
        A 2xn array defining points of the curve (x, y).
    """
    complex_points = sequence_to_complex_points_with_angle_fn(sequence, angle_fn, turn_iterations)
    return complex_to_real_points(complex_points)


def sequence_to_points(sequence: str, angle: float = np.pi / 2) -> np.ndarray:
    """
    Convert an L-system sequence to coordinate points using turtle graphics.
    
    Interprets the string as turtle graphics commands:
    - F, G: move forward
    - +: turn left by angle
    - -: turn right by angle
    
    Args:
        sequence: The L-system string to interpret
        angle: The rotation angle in radians (default: π/2 for 90 degrees)
    
    Returns:
        A 2xn array defining points of the curve (x, y).
    """
    return sequence_to_points_with_angle_fn(sequence, lambda i: angle)


def dragon_curve_with_angle_fn(iterations: int, angle_fn: Callable[[int], float]) -> np.ndarray:
    """
    Generate a dragon curve fractal using L-system with dynamic angles.
    
    Args:
        iterations: Number of iterations to apply the L-system rules
        angle_fn: Function that takes iteration number and returns rotation angle in radians
    
    Returns:
        A 2xn array defining points of the curve (x, y).
    """
    sequence, turn_iterations = generate_dragon_sequence(iterations)
    return sequence_to_points_with_angle_fn(sequence, angle_fn, turn_iterations)


def dragon_curve(iterations: int, angle: float = np.pi / 2) -> np.ndarray:
    """
    Generate a dragon curve fractal using L-system.
    
    Args:
        iterations: Number of iterations to apply the L-system rules
        angle: The rotation angle in radians (default: π/2 for 90 degrees)
    
    Returns:
        A 2xn array defining points of the curve (x, y).
    """
    return dragon_curve_with_angle_fn(iterations, lambda i: angle)
